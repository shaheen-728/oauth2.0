/*
 * 3gpp-monitoring-event
 *
 * API for Monitoring Event. Â© 2020, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * API version: 1.1.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type MonitoringEventAPISubscriptionLevelPOSTOperationApiService service

/*
MonitoringEventAPISubscriptionLevelPOSTOperationApiService Creates a new subscription resource for monitoring event notification
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body Subscription for notification about monitoring event
  - @param scsAsId Identifier of the SCS/AS

@return MonitoringEventReport
*/
func (a *MonitoringEventAPISubscriptionLevelPOSTOperationApiService) ScsAsIdSubscriptionsPost(ctx context.Context, body MonitoringEventSubscription, scsAsId string) (MonitoringEventSubscription, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue MonitoringEventSubscription
	)
	config := NewConfiguration()
	// create path and map variables
	localVarPath := config.BasePath + "/{scsAsId}/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"scsAsId"+"}", fmt.Sprintf("%v", scsAsId), -1)
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}
	client := http.Client{}
	localVarHttpResponse, err := client.Do(r)
	var response SubscriptionEventReportResponse
	err = json.NewDecoder(localVarHttpResponse.Body).Decode(&response)
	if err != nil {
		fmt.Println("Error decoding response:", err)
	}

	defer localVarHttpResponse.Body.Close()
	body1, err := ioutil.ReadAll(localVarHttpResponse.Body)
	if err != nil {
		fmt.Println(err)
	}
	//return body1,
	// Convert the response body to a string and print it
	fmt.Println(string(body1))

	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	//if localVarHttpResponse.StatusCode < 300 {
	//	fmt.Println("200")
	//	// If we succeed, return the data, otherwise pass on to decode error.
	//	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	//	if err == nil {
	//		return localVarReturnValue, localVarHttpResponse, err
	//	}
	//}
	var event_response MonitoringEventSubscription
	if localVarHttpResponse.StatusCode <= 300 {
		newErr := GenericSwaggerError{
			//body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			event_response.Self = body.Self
			event_response.SupportedFeatures = body.SupportedFeatures
			event_response.MtcProviderId = body.MtcProviderId
			event_response.Msisdn = body.Msisdn
			event_response.NotificationDestination = body.NotificationDestination
			event_response.MonitoringType = body.MonitoringType
			event_response.MonitorExpireTime = body.MonitorExpireTime
			event_response.MaximumNumberOfReports = body.MaximumNumberOfReports
			event_response.RepPeriod = body.RepPeriod
			//event_response.LocationType.Location = body.LocationType.Location
			//event_response.Accuracy.Accuracy = body.Accuracy.Accuracy

			event_response.MonitoringEventReport.LocationInfo.AgeOfLocationInfo = response.ReportList[0].Location.NrLocation.AgeOfLocationInformation
			event_response.MonitoringEventReport.LocationInfo.PlmnId = response.ReportList[0].Location.NrLocation.Tai.PlmnId.Mcc + response.ReportList[0].Location.NrLocation.Tai.PlmnId.Mnc
			event_response.MonitoringEventReport.LocationInfo.TrackingAreaId = response.ReportList[0].Location.NrLocation.Tai.Tac
			event_response.MonitoringEventReport.LocationInfo.CellId = response.ReportList[0].Location.NrLocation.Ncgi.NrCellId

			//event_response.MonitoringEventReport = &v
			//err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			//if err != nil {
			//	fmt.Println("return error")
			//	newErr.error = err.Error()
			//	fmt.Println(newErr.error)
			//	return localVarReturnValue, localVarHttpResponse, newErr
			//}
			//newErr.model = v

			return event_response, localVarHttpResponse, nil
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v MonitoringEventSubscription
			//err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			//if err != nil {
			//	newErr.error = err.Error()
			//	return localVarReturnValue, localVarHttpResponse, newErr
			//}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
